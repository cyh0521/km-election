<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vote for Kinmenï¸±é‡‘é–€é¸èˆ‰å„€è¡¨æ¿</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary: #3887B0;
            --bg: #f4f7f6;
            --card-bg: #ffffff;
            --text-main: #2c3e50;
            --text-sub: #7f8c8d;
            --border: #e1e4e8;
        }
        * { margin:0; padding:0; box-sizing:border-box; }
        
        /* èª¿æ•´ body padding é¨°å‡ºç©ºé–“çµ¦å›ºå®šçš„ header */
        body { 
            font-family:'Noto Sans TC', sans-serif; 
            background:var(--bg); 
            color:var(--text-main); 
            line-height:1.6; 
            padding-bottom: 20px; 
            padding-top: 50px; 
        }
        
        /* ç½®é ‚æ¨™é¡Œåˆ—æ¨£å¼ (å›ºå®šé«˜åº¦) */
        header { 
            background: #2c3e50; 
            color: white; 
            padding: 10px 20px; 
            text-align: center; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
            
            position: fixed; 
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000; 
        }
        
        h1 { 
            font-size: 20px; 
            font-weight: 700; 
            margin-bottom: 0; 
        }
        
        /* ã€ä¿®æ­£ 1ã€‘é å°¾è²æ˜æ¨£å¼èª¿æ•´ */
        footer {
            text-align: center;
            padding: 15px 15px; 
            margin-top: 40px; 
            /* ç§»é™¤èƒŒæ™¯è‰²å’Œé™°å½± */
            background: transparent; 
            color: #7f8c8d; /* æ·¡é»‘è‰²æ–‡å­— */
            font-size: 13px;
            box-shadow: none; 
        }

        /* ä¸‹æ‹‰é¸å–®åˆ— */
        .control-panel { 
            background: white; 
            padding: 15px; 
            display: flex; 
            justify-content: center; 
            gap: 15px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); 
            flex-wrap: wrap; 
            position: relative;
            z-index: 10;
        }
        
        select { padding: 8px 15px; border: 1px solid #ccc; border-radius: 6px; font-size: 16px; min-width: 200px; background-color: #fff; cursor: pointer; }
        
        .container { max-width: 1200px; margin: 20px auto; padding: 0 15px; }
        
        /* éºµåŒ…å±‘ */
        .breadcrumb { margin-bottom: 20px; font-size: 16px; color: var(--text-sub); padding: 10px 0; }
        #breadcrumb-bottom { margin-top: 40px; border-top: 1px solid var(--border); padding-top: 20px; }
        .breadcrumb span { cursor: pointer; color: var(--primary); font-weight: 500; }
        .breadcrumb span:hover { text-decoration: underline; }
        .breadcrumb span.active { color: var(--text-main); cursor: default; text-decoration: none; }
        
        /* å€å¡Šæ¨£å¼ */
        .main-section { margin-bottom: 40px; }
        .section-header { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid var(--border); }
        .section-title { font-size: 22px; font-weight: 700; color: var(--text-main); }
        .section-badge { background: var(--primary); color: white; padding: 4px 12px; border-radius: 20px; font-size: 13px; }

        /* å¡ç‰‡æ¨£å¼ */
        .card { background: var(--card-bg); border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); padding: 20px; overflow: hidden; border: 1px solid transparent; transition: all 0.2s; margin-bottom: 0; }
        .card.clickable { cursor: pointer; }
        .card.clickable:hover { transform: translateY(-3px); border-color: var(--primary); box-shadow: 0 8px 15px rgba(56, 135, 176, 0.15); }
        
        .card-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px; }
        .card-header-left { display: flex; flex-direction: column; }
        
        .card-title { font-size: 18px; font-weight: 700; color: var(--text-main); border-left: 4px solid var(--primary); padding-left: 10px; line-height: 1.2; }
        
        /* å¡ç‰‡å‰¯æ¨™é¡Œ (çµ±è¨ˆæ•¸æ“š) */
        .card-stats { font-size: 13px; color: #666; margin-top: 5px; margin-left: 14px; font-weight: 500; line-height: 1.8; }
        .card-stats strong { color: var(--text-main); font-weight: 700; }
        .card-stats .rate { color: #d9534f; font-weight: 700; }
        
        .card-action { font-size: 14px; color: var(--primary); font-weight: 500; white-space: nowrap; margin-left: 10px; }

        /* Layout Systems */
        .layout-full { display: grid; grid-template-columns: 300px 1fr; gap: 25px; align-items: start; }
        .layout-full .chart-area { height: 250px; width: 100%; position: relative; }

        .sub-area-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(480px, 1fr)); gap: 15px; }
        
        .layout-compact { display: flex; align-items: flex-start; gap: 20px; }
        .layout-compact .chart-area { flex: 0 0 140px; width: 140px; height: 140px; position: relative; margin-top: 10px; }
        .layout-compact .table-area { flex: 1; min-width: 0; }

        /* Table Styling */
        .table-responsive { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; font-size: 14px; } 
        th { 
            background: #f8f9fa; 
            color: #666; 
            font-weight: 600; 
            text-align: left; 
            padding: 6px 8px; 
            border-bottom: 2px solid var(--border); 
            white-space: nowrap; 
            font-size: 13px; 
            cursor: pointer; 
            position: relative; 
        }
        th:hover {
            background: #e9ecef;
        }
        td { padding: 8px 8px; border-bottom: 1px solid var(--border); vertical-align: middle; }
        
        /* æ’åºåœ–ç¤ºæ¨£å¼ */
        .sort-icon {
            display: inline-block;
            width: 0;
            height: 0;
            margin-left: 5px;
            vertical-align: middle;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            opacity: 0.3; 
        }
        .sort-icon.asc {
            border-bottom: 4px solid #333; 
            opacity: 1;
        }
        .sort-icon.desc {
            border-top: 4px solid #333; 
            opacity: 1;
        }
        
        /* åŸºç¤è™Ÿæ¬¡æ¨£å¼ */
        .number-badge {
            display: inline-block;
            width: 24px; 
            height: 24px;
            line-height: 24px;
            text-align: center; 
            background: #eee; 
            border-radius: 50%; 
            font-weight: 700; 
            font-size: 13px; 
            color: #555; 
            
            /* ã€ä¿®æ­£ 2ã€‘å°‡ vertical-align æ”¹ç‚º middle ä»¥ä¿®æ­£æ‰‹æ©Ÿé¡¯ç¤ºå•é¡Œ */
            vertical-align: middle;
        }
        
        /* ç•¶é¸è€…è™Ÿç¢¼æ¨£å¼ (æ¡ƒç´…è‰²åº•) */
        .winner-badge {
            background: #D9534F; 
            color: white; 
        }

        /* æ”¿é»¨å¾½ç« æ¨£å¼ */
        .party-badge { font-size: 11px; padding: 2px 6px; border-radius: 8px; color: white; background: #999; white-space: nowrap; }
        
        /* éŸ¿æ‡‰å¼æ”¿é»¨åç¨±æ§åˆ¶ (é è¨­ï¼šé¡¯ç¤ºé•·åç¨±ï¼Œéš±è—çŸ­åç¨±) */
        .party-cell .party-short {
            display: none; 
        }

        /* æ¡Œé¢ç‰ˆå¤§å‹æ‘˜è¦å¡ç‰‡çš„è¡¨æ ¼æ¨£å¼ (å¤§æ–¼ 768px æ™‚ç”Ÿæ•ˆ) */
        table.large-table {
            font-size: 17px; 
        }
        table.large-table th {
            padding: 10px 10px; 
            font-size: 14px; 
        }
        table.large-table td {
            padding: 10px 10px; 
        }
        /* æ›´æ–°å¤§å‹è¡¨æ ¼çš„è™Ÿæ¬¡æ¨£å¼ */
        table.large-table .number-badge {
            width: 26px; 
            height: 26px;
            line-height: 26px;
            font-size: 14px;
        }
        table.large-table .party-badge {
            font-size: 12px;
        }

        .vote-cell-content { display: flex; flex-direction: column; align-items: flex-end; gap: 2px; }
        .bar-container { height: 5px; background: #f0f0f0; border-radius: 3px; overflow: hidden; width: 100%; max-width: 80px; }
        .bar-fill { height: 100%; border-radius: 3px; }
        
        .loading-state { text-align: center; padding: 60px; color: var(--text-sub); font-size: 18px; }

        /* æ‰‹æ©Ÿç‰ˆæ¨£å¼èª¿æ•´ (å°æ–¼ç­‰æ–¼ 768px) */
        @media (max-width: 768px) {
            .layout-full { grid-template-columns: 1fr; }
            .sub-area-grid { grid-template-columns: 1fr; }
            .layout-compact { flex-direction: column; align-items: center; }
            .layout-compact .chart-area { width: 100%; height: 200px; flex: none; margin-bottom: 15px; }
            .layout-compact .table-area { width: 100%; }

            /* éŸ¿æ‡‰å¼æ”¿é»¨åç¨±æ§åˆ¶ (æ‰‹æ©Ÿï¼šéš±è—é•·åç¨±ï¼Œé¡¯ç¤ºçŸ­åç¨±) */
            .party-cell .party-long {
                display: none; 
            }
            .party-cell .party-short {
                display: inline-block;
            }
            .party-badge {
                 font-size: 11px; 
            }

            /* åœ¨æ‰‹æ©Ÿä¸Šï¼Œå°‡å¤§å‹è¡¨æ ¼é‚„åŸç‚ºæ¨™æº–å­—ç´šï¼Œé¿å…è¶…å‡ºè¢å¹•å¯¬åº¦ */
            table.large-table {
                font-size: 14px; 
            }
            table.large-table th {
                padding: 6px 8px; 
                font-size: 13px; 
            }
            table.large-table td {
                padding: 8px 8px; 
            }
            table.large-table .party-badge {
                font-size: 11px; 
            }
            
            /* ç¢ºä¿ number-badge æ˜¯æ¨™æº–å¤§å° */
            .number-badge {
                width: 22px; 
                height: 22px;
                line-height: 22px;
                font-size: 12px;
                vertical-align: middle; /* ç¢ºä¿æ‰‹æ©Ÿä¸Šä¹Ÿæ˜¯ middle */
            }
        }
    </style>
</head>
<body>

<header>
    <h1>Vote for Kinmenï¸±é‡‘é–€é¸èˆ‰å„€è¡¨æ¿</h1>
</header>

<div class="control-panel">
    <select id="typeSelect"></select>
    <select id="yearSelect"></select>
</div>

<div class="container">
    <div id="breadcrumb" class="breadcrumb" style="display:none;"></div>
    
    <div id="content">
        <div class="loading-state">è³‡æ–™è¼‰å…¥ä¸­...</div>
    </div>

    <div id="breadcrumb-bottom" class="breadcrumb" style="display:none;"></div>
</div>

<footer>
    Vote for Kinmenï¸±é‡‘é–€é¸èˆ‰å„€è¡¨æ¿ï¼è³‡æ–™ä¾†æºï¸±ä¸­å¤®é¸èˆ‰å§”å“¡æœƒé¸èˆ‰åŠå…¬æŠ•è³‡æ–™åº«
</footer>

<script>
    // ================= æ•¸æ“šèˆ‡è¨­å®šå€ =================
    
    const availableElections = [
        { 
            file: "2024_ç¸½çµ±å‰¯ç¸½çµ±.csv", 
            year: "2024", 
            type: "ç¸½çµ±å‰¯ç¸½çµ±", 
            uiName: "2024å¹´ ç¸½çµ±å‰¯ç¸½çµ±é¸èˆ‰" 
        },
        { 
            file: "2024_ç«‹æ³•å§”å“¡.csv", 
            year: "2024", 
            type: "ç«‹æ³•å§”å“¡", 
            uiName: "2024å¹´ ç«‹æ³•å§”å“¡é¸èˆ‰"
        }
    ];

    const partyColors = {
        "ä¸­åœ‹åœ‹æ°‘é»¨": "#3887B0",
        "æ°‘ä¸»é€²æ­¥é»¨": "#C0D65A",
        "å°ç£æ°‘çœ¾é»¨": "#28C8C8",
        "è¦ªæ°‘é»¨": "#F27C00",
        "æ–°é»¨": "#F0C800",
        "ç„¡é»¨ç±": "#606060",
        "default": "#7f8c8d"
    };

    function getPartyColor(party) {
        return partyColors[party] || partyColors['default'];
    }

    function getShortPartyName(party) {
        const shortNames = {
            "ä¸­åœ‹åœ‹æ°‘é»¨": "åœ‹æ°‘é»¨",
            "æ°‘ä¸»é€²æ­¥é»¨": "æ°‘é€²é»¨",
            "å°ç£æ°‘çœ¾é»¨": "æ°‘çœ¾é»¨",
            "è¦ªæ°‘é»¨": "è¦ªæ°‘é»¨", 
            "æ–°é»¨": "æ–°é»¨", 
            "ç„¡é»¨ç±": "ç„¡é»¨ç±",
            "default": "ç„¡"
        };
        return shortNames[party] || party;
    }

    const dom = {
        typeSelect: document.getElementById("typeSelect"),
        yearSelect: document.getElementById("yearSelect"),
        content: document.getElementById("content"),
        breadcrumb: document.getElementById("breadcrumb"),
        breadcrumbBottom: document.getElementById("breadcrumb-bottom"),
        header: document.querySelector('header')
    };

    let appState = {
        data: {},
        countyMetadata: {}, 
        currentLevel: 'county',
        currentTown: null,
        chartInstances: [],
        // é è¨­æ’åºç‚ºè™Ÿæ¬¡å‡åº
        sortConfig: { key: 'number', direction: 'asc' }, 
        globalTotalVotes: 0,
        electionName: "é¸èˆ‰è³‡æ–™" 
    };

    // ================= åˆå§‹åŒ–èˆ‡é¸å–®é‚è¼¯ (ç¶­æŒä¸è®Š) =================
    
    const electionTypes = [...new Set(availableElections.map(e => e.type))];
    
    dom.typeSelect.innerHTML = electionTypes.map(t => `<option value="${t}">${t}é¸èˆ‰</option>`).join('');

    dom.typeSelect.onchange = function() {
        const type = this.value;
        dom.yearSelect.innerHTML = ''; 

        const matchingElections = availableElections.filter(e => e.type === type);
        matchingElections.sort((a, b) => b.year - a.year); 

        matchingElections.forEach(e => {
            dom.yearSelect.innerHTML += `<option value="${e.file}">${e.uiName}</option>`;
        });

        if (matchingElections.length > 0) {
            dom.yearSelect.value = matchingElections[0].file;
            loadData(matchingElections[0].file);
        }
    };

    dom.yearSelect.onchange = function() {
        if (this.value) loadData(this.value);
    };

    (function init() {
        availableElections.sort((a, b) => b.year - a.year); 
        if (availableElections.length > 0) {
            const latestElection = availableElections[0];
            dom.typeSelect.value = latestElection.type;
            dom.typeSelect.onchange(); 
        } else {
             dom.content.innerHTML = `<div class="loading-state" style="color:red">ç„¡å¯ç”¨é¸èˆ‰è³‡æ–™</div>`;
        }
    })();


    // ================= è³‡æ–™è™•ç† (ç¶­æŒ parseCSV é‚è¼¯) =================

    function loadData(file) {
        dom.content.innerHTML = `<div class="loading-state">è³‡æ–™è¼‰å…¥ä¸­...</div>`;
        const electionMeta = availableElections.find(e => e.file === file);
        appState.electionName = electionMeta ? electionMeta.uiName : "é¸èˆ‰è³‡æ–™";
        
        fetch(file) 
            .then(r => { 
                if(!r.ok) throw new Error("æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆåç¨±èˆ‡è·¯å¾‘ã€‚"); 
                return r.text(); 
            })
            .then(csvText => {
                parseCSV(csvText);
                // è¼‰å…¥è³‡æ–™å¾Œï¼Œé‡è¨­æ’åºç‚ºè™Ÿæ¬¡å‡åº
                appState.sortConfig = { key: 'number', direction: 'asc' }; 
                renderCounty();
            })
            .catch(error => {
                console.error("è¼‰å…¥éŒ¯èª¤:", error);
                dom.content.innerHTML = `<div class="loading-state" style="color:red">è®€å– ${file} å¤±æ•—: ${error.message}</div>`;
            });
    }

    function parseCSV(text) {
        const rows = text.split('\n').map(r => r.trim()).filter(r => r).map(r => r.split(','));

        if (rows.length < 4) return;

        // 1. è§£æå€™é¸äººè³‡è¨Š (å¾ç¬¬ 1, 2, 3 è¡Œ)
        const headerRowIndices = []; 
        let currentIdx = 2;
        while(rows[0][currentIdx] && rows[1][currentIdx]) {
            headerRowIndices.push(currentIdx);
            currentIdx++;
        }
        
        const candInfo = [];
        
        headerRowIndices.forEach(colIndex => {
            const number = rows[0][colIndex] ? rows[0][colIndex].trim() : '';
            let name = rows[1][colIndex] ? rows[1][colIndex].trim() : '';
            let party = rows[2][colIndex] ? rows[2][colIndex].trim() : '';
            
            const isWinner = name.includes('*'); 
            name = name.replace('*', '').trim(); 
            
            party = party === 'ç„¡' ? 'ç„¡é»¨ç±' : party;

            if (name && number) {
                candInfo.push({ number: String(number), name, party, colIndex, isWinner }); 
            }
        });

        const candidates = {}; 
        const towns = {};
        const townOrder = [];
        let globalValidVotes = 0; 
        let globalInvalidVotes = 0; 
        let globalEligibleVoters = 0; 
        
        // 2. è¿­ä»£æ•¸æ“šè¡Œ (å¾ç¬¬ 4 è¡Œé–‹å§‹ï¼Œç´¢å¼• 3)
        const VOTES_COL = 5;
        const INVALID_COL = 6;
        const ELIGIBLE_COL = 7;

        for (let i = 3; i < rows.length; i++) {
            const row = rows[i];
            
            if (row.length < 8 || !row[0] || row[0].includes("é„‰é®")) continue;

            const town = row[0].trim();
            const village = row[1].trim();
            
            const parseNum = (val) => parseInt(String(val).replace(/[^0-9]/g, '')) || 0;

            const validVotes = parseNum(row[VOTES_COL]); 
            const invalidVotes = parseNum(row[INVALID_COL]); 
            const eligibleVoters = parseNum(row[ELIGIBLE_COL]); 
            
            globalValidVotes += validVotes;
            globalInvalidVotes += invalidVotes;
            globalEligibleVoters += eligibleVoters;

            if (!towns[town]) {
                towns[town] = { 
                    villages: {}, 
                    validVotes: 0, 
                    invalidVotes: 0,
                    eligibleVoters: 0,
                    candidates: {} 
                };
                townOrder.push(town);
            }
            
            towns[town].validVotes += validVotes;
            towns[town].invalidVotes += invalidVotes;
            towns[town].eligibleVoters += eligibleVoters;
            
            if (!towns[town].villages[village]) {
                 towns[town].villages[village] = { 
                     validVotes: 0, 
                     invalidVotes: 0,
                     eligibleVoters: 0,
                     candidates: {} 
                 };
            }
            towns[town].villages[village].validVotes += validVotes;
            towns[town].villages[village].invalidVotes += invalidVotes;
            towns[town].villages[village].eligibleVoters += eligibleVoters;
            
            
            candInfo.forEach(c => {
                const votes = parseNum(row[c.colIndex]);
                
                // ç¸£ç´šç¸½è¨ˆ
                if (!candidates[c.name]) candidates[c.name] = { number: c.number, party: c.party, votes: 0, isWinner: c.isWinner };
                candidates[c.name].votes += votes;
                
                // é„‰é®ç´šç¸½è¨ˆ
                if (!towns[town].candidates[c.name]) towns[town].candidates[c.name] = { number: c.number, party: c.party, votes: 0, isWinner: c.isWinner };
                towns[town].candidates[c.name].votes += votes;
                
                // æ‘é‡Œç´šç¸½è¨ˆ
                if (!towns[town].villages[village].candidates[c.name]) towns[town].villages[village].candidates[c.name] = { number: c.number, party: c.party, votes: 0, isWinner: c.isWinner };
                towns[town].villages[village].candidates[c.name].votes += votes;
            });
        }

        appState.data = { county: candidates, towns: towns, townOrder: [...new Set(townOrder)] };
        appState.countyMetadata = {
            validVotes: globalValidVotes,
            invalidVotes: globalInvalidVotes,
            eligibleVoters: globalEligibleVoters
        };
        appState.globalTotalVotes = globalValidVotes; 
    }

    // ================= æ’åºé‚è¼¯ (ç¶­æŒä¸è®Š) =================
    
    /**
     * é»æ“Šè¡¨é ­æ™‚èª¿ç”¨æ­¤å‡½æ•¸ä¾†æ›´æ”¹æ’åºè¨­å®šä¸¦é‡æ–°æ¸²æŸ“
     * @param {string} key æ’åºçš„éµ (number, name, party, votes)
     */
    window.sortTable = function(key) {
        
        const currentKey = appState.sortConfig.key;
        const currentDirection = appState.sortConfig.direction;
        
        let newDirection = 'desc'; 
        
        // é è¨­å‡åº (è™Ÿæ¬¡ã€åå­—ã€æ”¿é»¨)
        if (key === 'number' || key === 'name' || key === 'party') {
             newDirection = 'asc'; 
        }

        // å¦‚æœé»æ“Šç›¸åŒçš„éµï¼Œå‰‡åˆ‡æ›æ–¹å‘
        if (currentKey === key) {
            newDirection = currentDirection === 'asc' ? 'desc' : 'asc';
        }

        appState.sortConfig = { key: key, direction: newDirection };

        // é‡æ–°æ¸²æŸ“ç•¶å‰è¦–åœ– (å‚³é false è¡¨ç¤ºä¸éœ€è¦æ»¾å‹•)
        if (appState.currentLevel === 'county') {
            renderCounty(false); 
        } else if (appState.currentLevel === 'town') {
            renderTown(appState.currentTown, false); 
        }
    };
    
    function getSortedCandidates(candObj) {
        let list = Object.keys(candObj).map(key => ({ name: key, ...candObj[key] }));
        const { key, direction } = appState.sortConfig;
        
        list.sort((a, b) => {
            let valA = a[key], valB = b[key];

            if (key === 'number' || key === 'votes') { 
                valA = parseInt(valA) || 0; 
                valB = parseInt(valB) || 0;
            } else if (typeof valA === 'string') {
                 valA = valA.toLowerCase();
                 valB = valB.toLowerCase();
            }

            let comparison = 0;
            if (valA < valB) {
                comparison = -1;
            } else if (valA > valB) {
                comparison = 1;
            }

            return direction === 'asc' ? comparison : comparison * -1;
        });
        
        return list;
    }

    // ================= æ¸²æŸ“å‡½å¼ (ç¶­æŒä¸è®Š) =================

    window.renderCounty = function(shouldScroll = true) {
        destroyAllCharts();
        appState.currentLevel = 'county';
        appState.currentTown = null;
        if (shouldScroll) window.scrollTo(0,0); 
        updateBreadcrumb();

        const candidates = getSortedCandidates(appState.data.county);
        const metadata = appState.countyMetadata;

        let html = `<div class="main-section">
            <div class="section-header"><span class="section-title">${appState.electionName}</span></div>
            ${generateCardHTML('county-main', 'å…¨ç¸£é–‹ç¥¨çµæœ', candidates, metadata, false, false)}
        </div>`;

        html += `<div class="main-section">
            <div class="section-header"><span class="section-title">å„é„‰é®é–‹ç¥¨çµæœ</span><span class="section-badge">é»æ“Šå¡ç‰‡çœ‹ç´°ç¯€</span></div>
            <div class="sub-area-grid">`;
        
        appState.data.townOrder.forEach(town => {
            const townData = appState.data.towns[town];
            const townCands = getSortedCandidates(townData.candidates);
            
            const townMetadata = {
                validVotes: townData.validVotes,
                invalidVotes: townData.invalidVotes,
                eligibleVoters: townData.eligibleVoters
            };

            html += generateCardHTML(`town-${town}`, town, townCands, townMetadata, true, `renderTown('${town}')`, true);
        });
        html += `</div></div>`;

        dom.content.innerHTML = html;
        drawCharts(candidates, metadata.validVotes, appState.data.townOrder, 'towns');
    };

    window.renderTown = function(townName, shouldScroll = true) {
        destroyAllCharts();
        appState.currentLevel = 'town';
        appState.currentTown = townName;
        if (shouldScroll) window.scrollTo(0,0); 
        updateBreadcrumb();

        const townData = appState.data.towns[townName];
        const candidates = getSortedCandidates(townData.candidates);
        const villageList = Object.keys(townData.villages);
        
        const townMetadata = {
            validVotes: townData.validVotes,
            invalidVotes: townData.invalidVotes,
            eligibleVoters: townData.eligibleVoters
        };

        let html = `<div class="main-section">
            <div class="section-header"><span class="section-title">${townName} ç¸½è¨ˆ</span></div>
            ${generateCardHTML('town-main', `${townName}é–‹ç¥¨çµæœ`, candidates, townMetadata, false, false)}
        </div>`;

        html += `<div class="main-section">
            <div class="section-header"><span class="section-title">å„æ‘é‡Œé–‹ç¥¨çµæœ</span></div>
            <div class="sub-area-grid">`;
        
        villageList.forEach(village => {
            const vData = townData.villages[village];
            const vCands = getSortedCandidates(vData.candidates);
            
            const villageMetadata = {
                validVotes: vData.validVotes,
                invalidVotes: vData.invalidVotes,
                eligibleVoters: vData.eligibleVoters
            };

            html += generateCardHTML(`village-${village}`, village, vCands, villageMetadata, false, null, true);
        });
        html += `</div></div>`;

        dom.content.innerHTML = html;
        drawCharts(candidates, townMetadata.validVotes, villageList, 'villages', townData);
    };

    // ================= é€šç”¨è¼”åŠ©å‡½å¼ (ç¶­æŒ renderTableHeader ä¿®æ­£) =================

    function generateCardHTML(id, title, candidates, metadata, isClickable, onClickAction, isCompact = false) {
        const clickClass = isClickable ? 'clickable' : '';
        const clickAttr = isClickable ? `onclick="${onClickAction}"` : '';
        const actionText = isClickable ? `<span class="card-action">æŸ¥çœ‹è©³æƒ… âœ</span>` : '';
        const layoutClass = isCompact ? 'layout-compact' : 'layout-full';
        
        const tableSizeClass = isCompact ? '' : ' large-table';
        
        const { validVotes, invalidVotes, eligibleVoters } = metadata;
        
        const totalBallots = validVotes + invalidVotes;
        const turnoutRate = eligibleVoters > 0 ? (totalBallots / eligibleVoters * 100).toFixed(2) : "0.00";

        const cardStatsHTML = `
            <div class="card-stats">
                <span style="font-size:14px;"><strong>æœ‰æ•ˆç¥¨: ${validVotes.toLocaleString()}</strong> ç¥¨</span>
                | ç„¡æ•ˆç¥¨: ${invalidVotes.toLocaleString()} ç¥¨ 
                <br>
                é¸èˆ‰äººæ•¸: ${eligibleVoters.toLocaleString()} äºº 
                | æŠ•ç¥¨ç‡: <span class="rate">${turnoutRate}%</span>
            </div>
        `;

        const { key: currentSortKey, direction: currentSortDirection } = appState.sortConfig;

        // è¼”åŠ©å‡½æ•¸ï¼šç”Ÿæˆè¡¨é ­ HTML ä¸¦åŒ…å«æ’åºåœ–ç¤º
        function renderTableHeader(title, sortKey, style = '') {
            const isCurrentKey = currentSortKey === sortKey;
            const iconClass = isCurrentKey ? currentSortDirection : '';
            const iconHtml = `<span data-key="${sortKey}" class="sort-icon ${iconClass}"></span>`;
            
            // ä¿æŒ event.stopPropagation() ä»¥é˜²æ­¢é»æ“Šæ’åºæ™‚è§¸ç™¼çˆ¶å±¤å¡ç‰‡çš„ onclick äº‹ä»¶
            return `<th style="${style}" onclick="event.stopPropagation(); sortTable('${sortKey}')">${title} ${iconHtml}</th>`;
        }
        
        return `
        <div class="card ${clickClass}" ${clickAttr}>
            <div class="card-header">
                <div class="card-header-left">
                    <div class="card-title">${title}</div>
                    ${cardStatsHTML}
                </div>
                ${actionText}
            </div>
            <div class="${layoutClass}">
                <div class="chart-area">
                    <canvas id="chart-${id}"></canvas>
                </div>
                <div class="table-area table-responsive">
                    <table class="${tableSizeClass}">
                        <thead>
                            <tr>
                                ${renderTableHeader('#', 'number', 'width:40px; text-align:center;')} 
                                ${renderTableHeader('å€™é¸äºº', 'name', '')}
                                ${renderTableHeader('æ”¿é»¨', 'party', '')}
                                ${renderTableHeader('å¾—ç¥¨', 'votes', 'text-align:right')}
                                ${renderTableHeader('%', 'votes', 'text-align:right; width:50px')}
                            </tr>
                        </thead>
                        <tbody>
                            ${candidates.map(c => {
                                const rate = validVotes > 0 ? (c.votes / validVotes * 100).toFixed(2) : 0;
                                const color = getPartyColor(c.party);
                                
                                const badgeClass = c.isWinner ? 'number-badge winner-badge' : 'number-badge';
                                
                                return `
                                    <tr>
                                        <td style="text-align:center;">
                                            <span class="${badgeClass}" title="${c.isWinner ? 'ç•¶é¸è€…' : ''}">${c.number}</span>
                                        </td>
                                        <td style="font-weight:700">${c.name}</td>
                                        <td class="party-cell">
                                            <span class="party-badge party-long" style="background:${color}">${c.party}</span>
                                            <span class="party-badge party-short" style="background:${color}">${getShortPartyName(c.party)}</span>
                                        </td>
                                        <td style="text-align:right">
                                            <div class="vote-cell-content">
                                                <span>${c.votes.toLocaleString()}</span>
                                                <div class="bar-container"><div class="bar-fill" style="width:${rate}%; background:${color}"></div></div>
                                            </div>
                                        </td>
                                        <td style="text-align:right; font-weight:bold; color:${color}">${rate}%</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>`;
    }

    function destroyAllCharts() {
        appState.chartInstances.forEach(c => c.destroy());
        appState.chartInstances = [];
    }

    function updateBreadcrumb() {
        const { currentLevel, currentTown, electionName } = appState;
        // éºµåŒ…å±‘é»æ“Šäº‹ä»¶ç¾åœ¨å¸¶å…¥ shouldScroll = true åƒæ•¸ï¼Œç¢ºä¿å›é ‚
        let html = `<span onclick="renderCounty(true)">ğŸ  ${electionName}</span>`;
        if (currentLevel !== 'county') html += ` &gt; <span onclick="renderTown('${currentTown}', true)" class="active">${currentTown}</span>`;
        
        dom.breadcrumb.style.display = 'block';
        dom.breadcrumb.innerHTML = html;
        dom.breadcrumbBottom.style.display = 'block';
        dom.breadcrumbBottom.innerHTML = html;
    }

    function drawCharts(mainCands, mainTotal, subList, subType, townData = null) {
        const mainId = subType === 'towns' ? 'chart-county-main' : 'chart-town-main';
        drawChart(mainId, mainCands, mainTotal, false);

        subList.forEach(key => {
            let data, id;
            if (subType === 'towns') {
                data = appState.data.towns[key];
                id = `chart-town-${key}`;
            } else {
                data = townData.villages[key];
                id = `chart-village-${key}`;
            }
            const cands = getSortedCandidates(data.candidates);
            drawChart(id, cands, data.validVotes, true);
        });
    }

    function drawChart(canvasId, candidates, totalVotes, hideLegend = false) {
        const ctx = document.getElementById(canvasId);
        if(!ctx) return;

        const labels = candidates.map(c => c.name);
        const data = candidates.map(c => c.votes);
        const colors = candidates.map(c => getPartyColor(c.party));
        const chartType = candidates.length > 5 ? 'bar' : 'doughnut';

        const chart = new Chart(ctx.getContext('2d'), {
            type: chartType,
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: colors,
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        display: !hideLegend, 
                        position: 'bottom',
                        labels: { boxWidth: 12, padding: 10, font: { size: 11 } }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw;
                                const percentage = totalVotes > 0 ? (value / totalVotes * 100).toFixed(2) : 0;
                                return [
                                    `å¾—ç¥¨æ•¸: ${value.toLocaleString()} ç¥¨`,
                                    `å¾—ç¥¨ç‡: ${percentage}%`
                                ];
                            },
                            title: function(context) {
                                return context[0].label; 
                            }
                        }
                    }
                },
                layout: { padding: 0 }
            }
        });
        appState.chartInstances.push(chart);
    }
</script>
</body>
</html>
