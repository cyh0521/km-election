<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vote for Kinmenï¸±é‡‘é–€é¸èˆ‰å„€è¡¨æ¿</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #3887B0;
            --secondary: #2c3e50; 
            --bg: #f4f7f6;
            --card-bg: #ffffff;
            --text-main: #2c3e50;
            --text-sub: #7f8c8d;
            --border: #e1e4e8;
        }
        * { margin:0; padding:0; box-sizing:border-box; }
        
        body { 
            font-family:'Noto Sans TC', sans-serif; 
            background:var(--bg); 
            color:var(--text-main); 
            line-height:1.6; 
            padding-bottom: 20px; 
            padding-top: 50px; 
        }
        
        /* ç½®é ‚æ¨™é¡Œåˆ—æ¨£å¼ */
        header { 
            background: var(--secondary); 
            color: white; 
            padding: 10px 20px; 
            text-align: center; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
            position: fixed; 
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000; 
        }
        
        h1 { font-size: 20px; font-weight: 700; margin: 0; }
        h1 span { cursor: pointer; } 
        
        .container { max-width: 1200px; margin: 20px auto; padding: 0 15px; }
        
        /* --- ä¸»é¸å–®æ¨£å¼ --- */
        
        .main-menu-grid {
            display: grid;
            /* æ¡Œé¢ç‰ˆï¼šè‡ªé©æ‡‰ä½ˆå±€ï¼Œæœ€å° 180px */
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); 
            gap: 15px; 
            margin-bottom: 50px;
        }

        .menu-button {
            background: var(--card-bg);
            border: 1px solid var(--border); 
            border-radius: 8px; 
            padding: 15px 20px; 
            text-align: center;
            font-size: 16px; 
            font-weight: 500; 
            color: var(--secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); 
            line-height: 1.4;
        }
        
        .menu-button:hover {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
            transform: translateY(-2px); 
            box-shadow: 0 4px 10px rgba(56, 135, 176, 0.2);
        }
        
        .menu-icon { display: none; } 

        .menu-section-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--secondary);
            margin-bottom: 25px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border);
        }

        /* --- é¸èˆ‰åˆ—è¡¨ / æ‘˜è¦å¡ç‰‡æ¨£å¼ --- */
        .election-list-grid {
             display: grid;
             grid-template-columns: repeat(2, 1fr); 
             gap: 20px;
             margin-top: 20px;
        }
        
        /* --- å„€è¡¨æ¿èˆŠæœ‰æ¨£å¼ç¶­æŒ --- */
        
        .breadcrumb { margin-bottom: 20px; font-size: 16px; color: var(--text-sub); padding: 10px 0; }
        #breadcrumb-bottom { margin-top: 40px; border-top: 1px solid var(--border); padding-top: 20px; }
        .breadcrumb span { cursor: pointer; color: var(--primary); font-weight: 500; }
        .breadcrumb span:hover { text-decoration: underline; }
        .breadcrumb span.active { color: var(--text-main); cursor: default; text-decoration: none; }
        
        .main-section { margin-bottom: 40px; }
        .section-header { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid var(--border); }
        .section-title { font-size: 22px; font-weight: 700; color: var(--text-main); }
        .section-badge { background: var(--primary); color: white; padding: 4px 12px; border-radius: 20px; font-size: 13px; }

        /* å¡ç‰‡ä¸»é«”ï¼Œpadding ç‚º 20pxï¼Œè®“å…§å®¹è²¼é½Šé‚Šç·£ */
        .card { background: var(--card-bg); border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); padding: 20px; overflow: hidden; border: 1px solid transparent; transition: all 0.2s; margin-bottom: 0; }
        .card.clickable { cursor: pointer; }
        .card.clickable:hover { transform: translateY(-3px); border-color: var(--primary); box-shadow: 0 8px 15px rgba(56, 135, 176, 0.15); }
        
        /* å¡ç‰‡æ¨™é ­ï¼šå·¦å³å°é½Šï¼Œä¸¦è®“å·¦é‚Šå¯æ”¶ç¸® */
        .card-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start; 
            margin-bottom: 15px; 
            overflow: hidden; 
        }
        .card-header-left { 
            display: flex; 
            flex-direction: column; 
            flex-shrink: 1; 
            min-width: 0;
        }
        
        .card-title { font-size: 18px; font-weight: 700; color: var(--text-main); border-left: 4px solid var(--primary); padding-left: 10px; line-height: 1.2; }
        
        /* å„€è¡¨æ¿å…§é å¡ç‰‡çµ±è¨ˆæ•¸æ“šæ¨£å¼ (éæ‘˜è¦) */
        .card-stats { 
            font-size: 13px; 
            color: var(--text-main); 
            margin-top: 5px; 
            margin-left: 14px; 
            font-weight: 500; 
            line-height: 1.8; 
        }
        
        .card-stats strong { 
            font-weight: 500; 
            color: var(--text-main);
        }
        
        .card-stats .rate { color: #d9534f; font-weight: 700; }
        
        /* æ‘˜è¦å¡ç‰‡çµ±è¨ˆæ•¸æ“šæ¨£å¼ (é¦–é /åˆ—è¡¨é ) */
        .card.is-summary .card-stats {
            margin-top: 5px;
            margin-left: 14px;
            font-size: 14px; 
            line-height: 1.5;
            color: var(--text-main);
        }

        .card.is-summary .card-stats strong {
             color: var(--text-main); 
             font-weight: 500; 
        }
        .card.is-summary .card-stats .rate {
             color: #d9534f; 
        }

        /* è®“ action text ä¿æŒåœ¨æœ€å³é‚Šï¼Œä¸¦é˜²æ­¢è¢«æ“ å£“ */
        .card-action { 
            font-size: 14px; 
            color: var(--primary); 
            font-weight: 500; 
            white-space: nowrap; 
            margin-left: 10px; 
            flex-shrink: 0; 
            align-self: flex-start; 
            padding-top: 2px; 
        }

        /* ç§»é™¤åœ–è¡¨å€å¡Šå¾Œï¼Œè®“å…§å®¹å€åŸŸæ’æ»¿å¡ç‰‡ */
        .layout-full, .layout-compact { 
            display: block; /* å–æ¶ˆ Grid/Flex ä½ˆå±€ */
        }

        .sub-area-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(480px, 1fr)); gap: 15px; }
        
        /* ç°¡æ½”å¡ç‰‡ä½ˆå±€ (ç”¨æ–¼é„‰é®/æ‘é‡Œæˆ–é¦–é æ‘˜è¦) */
        .layout-compact .table-area { flex: 1; min-width: 0; }

        .table-responsive { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; font-size: 14px; table-layout: auto; } 
        th { 
            background: #f8f9fa; 
            color: #666; 
            font-weight: 600; 
            text-align: left; 
            padding: 6px 8px; 
            border-bottom: 2px solid var(--border); 
            white-space: nowrap; 
            font-size: 13px; 
            cursor: pointer; 
            position: relative; 
        }
        th:hover { background: #e9ecef; }
        td { padding: 8px 8px; border-bottom: 1px solid var(--border); vertical-align: middle; }
        
        /* è™Ÿç¢¼æ¬„ä½ */
        table th:nth-child(1),
        table td:nth-child(1) { width: 40px; text-align: center; } 
        
        /* å¾—ç¥¨æ•¸æ¬„ä½ */
        table th:last-child,
        table td:last-child { width: 50px; text-align: right; } /* å¾—ç¥¨ç‡å›ºå®šå°å¯¬åº¦ */
        
        /* é•·æ¢åœ–å®¹å™¨æ¨£å¼ */
        .bar-container { 
            height: 5px; 
            background: #f0f0f0; 
            border-radius: 3px; 
            overflow: hidden; 
            width: 100%; 
            /* è®“é•·æ¢åœ–æ¬„ä½ä½”ç”¨ 150px å¯¬åº¦ */
            max-width: 150px; 
        }
        .bar-fill { height: 100%; border-radius: 3px; }
        
        /* é•·æ¢åœ–æ¬„ä½ (æ–°çš„ç¨ç«‹æ¬„ä½) */
        .col-bar { 
             /* ç¢ºä¿é•·æ¢åœ–æ¬„ä½å¯¬åº¦å›ºå®šï¼Œé˜²æ­¢æ“ å£“ */
            width: 150px; 
            padding-left: 10px; /* å¢åŠ é–“éš” */
            padding-right: 10px; 
        }
        
        td.number-cell { text-align: center; }
        
        .sort-icon {
            display: inline-block; width: 0; height: 0; margin-left: 5px; vertical-align: middle; border-left: 4px solid transparent; border-right: 4px solid transparent; opacity: 0.3; 
        }
        .sort-icon.asc { border-bottom: 4px solid #333; opacity: 1; }
        .sort-icon.desc { border-top: 4px solid #333; opacity: 1; }
        
        .number-badge {
            display: inline-block; width: 24px; height: 24px; line-height: 24px; text-align: center; background: #eee; border-radius: 50%; font-weight: 700; font-size: 13px; color: #555; vertical-align: middle;
        }

        .party-badge { font-size: 11px; padding: 2px 6px; border-radius: 8px; color: white; background: #999; white-space: nowrap; }
        
        .party-cell .party-short { display: none; }
        
        /* æ¡Œé¢ç‰ˆï¼šé¡¯ç¤ºå®Œæ•´æ”¿é»¨åç¨± */
        .col-party .party-title-desktop { display: inline; }
        .col-party .party-title-mobile { display: none; }


        table.large-table { font-size: 17px; table-layout: auto; }
        table.large-table th { padding: 10px 10px; font-size: 14px; }
        table.large-table td { padding: 10px 10px; }
        table.large-table .number-badge { width: 26px; height: 26px; line-height: 26px; font-size: 14px; }
        table.large-table .party-badge { font-size: 12px; }

        .loading-state { text-align: center; padding: 60px; color: var(--text-sub); font-size: 18px; }

        @media (max-width: 768px) {
             /* æ‰‹æ©Ÿç‰ˆï¼šå¼·åˆ¶ä¸»é¸å–®æŒ‰éˆ•é›™æ¬„é¡¯ç¤º (å…ˆå‰è¦æ±‚) */
             .main-menu-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            /* æ‰‹æ©Ÿç‰ˆæŒ‰éˆ•æ¨£å¼èª¿æ•´ */
            .menu-button {
                padding: 15px 5px; 
            }
             .menu-text {
                font-size: 14px;
            }

             /* æ‰‹æ©Ÿç‰ˆï¼šæ‘˜è¦å¡ç‰‡åˆ—è¡¨é–å®šç‚ºå–®æ¬„ */
             .election-list-grid { grid-template-columns: 1fr; }
             
             /* ç°¡æ½”å¡ç‰‡åœ¨æ‰‹æ©Ÿä¸Šèª¿æ•´ */
             .layout-compact { flex-direction: column; align-items: center; }
             .layout-compact .table-area { width: 100%; }

             /* å…¶ä»–ä¿æŒä¸€è‡´ */
            .layout-full { grid-template-columns: 1fr; }
            .sub-area-grid { grid-template-columns: 1fr; }
            .party-cell .party-long { display: none; }
            .party-cell .party-short { display: inline-block; }
            .party-badge { font-size: 11px; }

            table.large-table { font-size: 14px; }
            table.large-table th { padding: 6px 8px; font-size: 13px; }
            table.large-table td { padding: 8px 8px; }
            table.large-table .party-badge { font-size: 11px; }
            
            td.number-cell { text-align: center; line-height: 22px; }
            
            .number-badge { width: 22px; height: 22px; line-height: 22px; font-size: 12px; vertical-align: middle; }

            /* æ‰‹æ©Ÿç‰ˆï¼šéš±è—ã€Œæ¨è–¦æ”¿é»¨ã€ï¼Œé¡¯ç¤ºã€Œæ”¿é»¨ã€ */
            .col-party .party-title-desktop { display: none; }
            .col-party .party-title-mobile { display: inline; }
        }
        
        /* --- é å°¾ç¸½é«”æ¨£å¼ (Footer) --- */
        footer {
            padding: 15px 15px;
            margin-top: 40px; 
            border-top: 1px solid var(--border); 
            background: #fafafa; 
            text-align: center; 
            font-size: 12px; 
            color: #999; 
            line-height: 1.6;
        }

        /* æ¡Œé¢ç‰ˆï¼ˆ> 768pxï¼‰é å°¾æ¨£å¼èª¿æ•´ */
        @media (min-width: 769px) {
            #footer-source {
                display: inline;
            }
        }
    </style>
</head>
<body>

<header>
    <h1><span onclick="renderMainMenu()">Vote for Kinmenï¸±é‡‘é–€é¸èˆ‰å„€è¡¨æ¿</span></h1>
</header>

<div class="container">
    <div id="breadcrumb" class="breadcrumb" style="display:none;"></div>
    
    <div id="content">
        <div class="loading-state">è³‡æ–™è¼‰å…¥ä¸­...</div>
    </div>

    <div id="breadcrumb-bottom" class="breadcrumb" style="display:none;"></div>
</div>

<footer>
    <span id="footer-source">è³‡æ–™ä¾†æºï¸±ä¸­é¸æœƒé¸èˆ‰è³‡æ–™åº«</span>
</footer>

<script>
    
    // ================= æ•¸æ“šèˆ‡è¨­å®šå€ =================
    
    const availableElections = [
        { 
            file: "2024_ç¸½çµ±å‰¯ç¸½çµ±.csv", 
            year: "2024", 
            type: "ç¸½çµ±å‰¯ç¸½çµ±", 
            uiName: "2024å¹´ ç¸½çµ±å‰¯ç¸½çµ±é¸èˆ‰",
            summaryData: null 
        },
        { 
            file: "2024_ç«‹æ³•å§”å“¡.csv", 
            year: "2024", 
            type: "ç«‹æ³•å§”å“¡", 
            uiName: "2024å¹´ ç«‹æ³•å§”å“¡é¸èˆ‰",
            summaryData: null
        },
        { 
            file: "2019_ç«‹æ³•å§”å“¡ï¼ˆè£œé¸ï¼‰.csv", 
            year: "2019", 
            type: "ç«‹æ³•å§”å“¡", 
            uiName: "2019å¹´ ç«‹æ³•å§”å“¡ï¼ˆè£œé¸ï¼‰",
            summaryData: null
        }
    ];
    
    const electionCategories = [
        { type: "ç¸½çµ±å‰¯ç¸½çµ±", icon: "ğŸ›ï¸" },
        { type: "ç«‹æ³•å§”å“¡", icon: "âš–ï¸" },
        { type: "åœ‹å¤§ä»£è¡¨", icon: "ğŸ“œ" },
        { type: "ç¸£é•·", icon: "ğŸ‘¨â€ğŸ’¼" },
        { type: "ç¸£è­°å“¡", icon: "ğŸ˜ï¸" },
        { type: "é„‰é®é•·", icon: "ğŸ¢" },
        { type: "é„‰é®æ°‘ä»£è¡¨", icon: "ğŸ‘¥" },
        { type: "æ‘é‡Œé•·", icon: "ğŸ¡" }
    ];

    // **æ”¿é»¨åŸºç¤é¡è‰² (å·²é‚„åŸç„¡é»¨ç±é¡è‰²)**
    const partyColors = {
        "ä¸­åœ‹åœ‹æ°‘é»¨": "#3887B0",
        "æ°‘ä¸»é€²æ­¥é»¨": "#67C167", 
        "å°ç£æ°‘çœ¾é»¨": "#28C8C8",
        "è¦ªæ°‘é»¨": "#F27C00",
        "æ–°é»¨": "#F0C800",
        "é‡‘é–€é«˜ç²±é»¨": "#990033", 
        "ç„¡é»¨ç±": "#AAAAAA",      // å·²é‚„åŸç‚ºä¸­æ€§æ·ºç°è‰²
        "default": "#7f8c8d"
    };

    let appState = {
        data: {},
        countyMetadata: {}, 
        currentLevel: 'mainMenu', 
        currentTown: null,
        // chartInstances: [], // ç§»é™¤åœ–è¡¨å¯¦ä¾‹è¿½è¹¤
        sortConfig: { key: 'number', direction: 'asc' }, 
        globalTotalVotes: 0,
        electionName: "é¸èˆ‰è³‡æ–™"
    };
    
    function getPartyColor(party) {
        // ä¿®æ­£ï¼šè™•ç†ç„¡é»¨ç±ç·¨è™Ÿå•é¡Œ
        const isIndependent = party.startsWith('ç„¡é»¨ç±');
        if (isIndependent) {
            // å˜—è©¦å¾ partyColors æŸ¥æ‰¾å®Œæ•´éµï¼Œå¦å‰‡ fallback åˆ°åŸºç¤ 'ç„¡é»¨ç±'
            return partyColors[party] || partyColors['ç„¡é»¨ç±']; 
        }
        return partyColors[party] || partyColors['default'];
    }

    function getShortPartyName(party) {
        const shortNamesMap = {
            "ä¸­åœ‹åœ‹æ°‘é»¨": "åœ‹æ°‘é»¨",
            "æ°‘ä¸»é€²æ­¥é»¨": "æ°‘é€²é»¨",
            "å°ç£æ°‘çœ¾é»¨": "æ°‘çœ¾é»¨",
            "è¦ªæ°‘é»¨": "è¦ªæ°‘é»¨", 
            "æ–°é»¨": "æ–°é»¨", 
            "é‡‘é–€é«˜ç²±é»¨": "é«˜ç²±é»¨", 
            "ç„¡é»¨ç±": "ç„¡é»¨ç±",
            "default": "ç„¡"
        };
        return shortNamesMap[party] || party;
    }

    const dom = {
        content: document.getElementById("content"),
        breadcrumb: document.getElementById("breadcrumb"),
        breadcrumbBottom: document.getElementById("breadcrumb-bottom"),
        header: document.querySelector('header')
    };


    // ================= è³‡æ–™è¼‰å…¥èˆ‡è§£æ =================
    
    function parseCSV(text) {
        const rows = text.split('\n').map(r => r.trim()).filter(r => r).map(r => r.split(','));

        if (rows.length < 4) return;

        const headerRowIndices = []; 
        let currentIdx = 2;
        while(rows[0][currentIdx] && rows[1][currentIdx]) {
            headerRowIndices.push(currentIdx);
            currentIdx++;
        }
        
        const VOTES_COL = currentIdx; 
        const INVALID_COL = currentIdx + 1;
        const ELIGIBLE_COL = currentIdx + 2;

        const candInfo = [];
        let independentCounter = 1;
        
        headerRowIndices.forEach(colIndex => {
            const number = rows[0][colIndex] ? rows[0][colIndex].trim() : '';
            let name = rows[1][colIndex] ? rows[1][colIndex].trim() : '';
            let party = rows[2][colIndex] ? rows[2][colIndex].trim() : '';
            
            const isWinner = name.includes('*'); 
            name = name.replace('*', '').trim(); 
            
            party = party === 'ç„¡' ? 'ç„¡é»¨ç±' : party;

            if (name && number) {
                // æ¢å¾©èˆŠç‰ˆç„¡é»¨ç±é‚è¼¯ï¼šä½¿ç”¨ç¡¬ç·¨ç¢¼éµå€¼å€åˆ†
                if (party === 'ç„¡é»¨ç±' && independentCounter <= 4) {
                    party = `ç„¡é»¨ç±-${independentCounter}`;
                    independentCounter++;
                }

                candInfo.push({ number: String(number), name, party, colIndex, isWinner }); 
            }
        });

        const candidates = {}; 
        const towns = {};
        const townOrder = [];
        let globalValidVotes = 0; 
        let globalInvalidVotes = 0; 
        let globalEligibleVoters = 0; 
        
        for (let i = 3; i < rows.length; i++) {
            const row = rows[i];
            
            // æª¢æŸ¥è¡Œé•·åº¦æ˜¯å¦è¶³å¤ åŒ…å«æ‰€æœ‰å¿…è¦çš„æ¬„ä½
            if (row.length < (ELIGIBLE_COL + 1) || !row[0] || row[0].includes("é„‰é®")) continue; 

            const town = row[0].trim();
            const village = row[1].trim();
            
            const parseNum = (val) => parseInt(String(val).replace(/[^0-9]/g, '')) || 0;

            const validVotes = parseNum(row[VOTES_COL]); 
            const invalidVotes = parseNum(row[INVALID_COL]); 
            const eligibleVoters = parseNum(row[ELIGIBLE_COL]); 
            
            globalValidVotes += validVotes;
            globalInvalidVotes += invalidVotes;
            globalEligibleVoters += eligibleVoters;

            if (!towns[town]) {
                towns[town] = { 
                    villages: {}, 
                    validVotes: 0, 
                    invalidVotes: 0,
                    eligibleVoters: 0,
                    candidates: {} 
                };
                townOrder.push(town);
            }
            
            towns[town].validVotes += validVotes;
            towns[town].invalidVotes += invalidVotes;
            towns[town].eligibleVoters += eligibleVoters;
            
            if (!towns[town].villages[village]) {
                 towns[town].villages[village] = { 
                     validVotes: 0, 
                     invalidVotes: 0,
                     eligibleVoters: 0,
                     candidates: {} 
                 };
            }
            towns[town].villages[village].validVotes += validVotes;
            towns[town].villages[village].invalidVotes += invalidVotes;
            towns[town].villages[village].eligibleVoters += eligibleVoters;
            
            
            candInfo.forEach(c => {
                const votes = parseNum(row[c.colIndex]);
                
                if (!candidates[c.name]) candidates[c.name] = { number: c.number, party: c.party, votes: 0, isWinner: c.isWinner };
                candidates[c.name].votes += votes;
                
                if (!towns[town].candidates[c.name]) towns[town].candidates[c.name] = { number: c.number, party: c.party, votes: 0, isWinner: c.isWinner };
                towns[town].candidates[c.name].votes += votes;
                
                if (!towns[town].villages[village].candidates[c.name]) towns[town].villages[village].candidates[c.name] = { number: c.number, party: c.party, votes: 0, isWinner: c.isWinner };
                towns[town].villages[village].candidates[c.name].votes += votes;
            });
        }

        appState.data = { county: candidates, towns: towns, townOrder: [...new Set(townOrder)] };
        appState.countyMetadata = {
            validVotes: globalValidVotes,
            invalidVotes: globalInvalidVotes,
            eligibleVoters: globalEligibleVoters
        };
        appState.globalTotalVotes = globalValidVotes; 
    }

    function loadData(file, uiName) {
        dom.content.innerHTML = `<div class="loading-state">æ­£åœ¨è¼‰å…¥ ${uiName} å®Œæ•´æ•¸æ“š...</div>`;
        
        appState.electionName = uiName;
        
        fetch(file) 
            .then(r => { 
                if(!r.ok) throw new Error("æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆåç¨±èˆ‡è·¯å¾‘ã€‚"); 
                return r.text(); 
            })
            .then(csvText => {
                parseCSV(csvText);
                appState.sortConfig = { key: 'number', direction: 'asc' }; 
                renderCounty(true); 
            })
            .catch(error => {
                console.error("è¼‰å…¥éŒ¯èª¤:", error);
                dom.content.innerHTML = `<div class="loading-state" style="color:red">è®€å– ${file} å¤±æ•—: ${error.message}<br>è«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦ä¸Šå‚³æˆåŠŸã€‚</div>`;
            });
    }
    
    // ================= è³‡æ–™è¼‰å…¥èˆ‡è§£æ (æ‘˜è¦å¡ç‰‡å°ˆç”¨ï¼šç¸£ç´šæ•¸æ“š) =================
    
    function extractCountySummary(text) {
        const rows = text.split('\n').map(r => r.trim()).filter(r => r).map(r => r.split(','));

        if (rows.length < 4) return null;

        const headerRowIndices = []; 
        let currentIdx = 2;
        while(rows[0][currentIdx] && rows[1][currentIdx]) {
            headerRowIndices.push(currentIdx);
            currentIdx++;
        }
        
        const VOTES_COL = currentIdx; 
        const INVALID_COL = currentIdx + 1;
        const ELIGIBLE_COL = currentIdx + 2;

        const candInfo = [];
        let independentCounter = 1;
        
        headerRowIndices.forEach(colIndex => {
            const number = rows[0][colIndex] ? rows[0][colIndex].trim() : '';
            let name = rows[1][colIndex] ? rows[1][colIndex].trim() : '';
            let party = rows[2][colIndex] ? rows[2][colIndex].trim() : '';
            
            name = name.replace('*', '').trim(); 
            party = party === 'ç„¡' ? 'ç„¡é»¨ç±' : party;

            if (name && number) {
                // æ¢å¾©èˆŠç‰ˆç„¡é»¨ç±é‚è¼¯ï¼šä½¿ç”¨ç¡¬ç·¨ç¢¼éµå€¼å€åˆ†
                 if (party === 'ç„¡é»¨ç±' && independentCounter <= 4) {
                    party = `ç„¡é»¨ç±-${independentCounter}`;
                    independentCounter++;
                }

                candInfo.push({ number: String(number), name, party, colIndex }); 
            }
        });
        
        const candidates = {}; 
        let globalValidVotes = 0; 
        let globalInvalidVotes = 0; 
        let globalEligibleVoters = 0; 
        
        for (let i = 3; i < rows.length; i++) {
            const row = rows[i];
            
            if (row.length < (ELIGIBLE_COL + 1) || !row[0] || row[0].includes("é„‰é®")) continue;

            const parseNum = (val) => parseInt(String(val).replace(/[^0-9]/g, '')) || 0;

            const validVotes = parseNum(row[VOTES_COL]); 
            const invalidVotes = parseNum(row[INVALID_COL]); 
            const eligibleVoters = parseNum(row[ELIGIBLE_COL]); 
            
            globalValidVotes += validVotes;
            globalInvalidVotes += invalidVotes;
            globalEligibleVoters += eligibleVoters;
            
            candInfo.forEach(c => {
                const votes = parseNum(row[c.colIndex]);
                
                if (!candidates[c.name]) candidates[c.name] = { number: c.number, party: c.party, votes: 0 };
                candidates[c.name].votes += votes;
            });
        }
        
        let allCandidatesList = Object.keys(candidates).map(key => ({ name: key, ...candidates[key] }));
        
        return {
            allCandidates: allCandidatesList,
            metadata: {
                validVotes: globalValidVotes,
                invalidVotes: globalInvalidVotes,
                eligibleVoters: globalEligibleVoters
            }
        };
    }
    
    async function loadAllElectionSummaries(elections) {
        const summaryPromises = elections.map(async e => {
            try {
                const response = await fetch(e.file);
                if (!response.ok) throw new Error("æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆåç¨±èˆ‡è·¯å¾‘ã€‚");
                const csvText = await response.text();
                
                const summary = extractCountySummary(csvText);
                
                if (summary) {
                    const sortedAllCands = getSortedCandidatesFromList(summary.allCandidates, { key: 'votes', direction: 'desc' });
                    
                    e.summaryData = {
                        allCandidates: sortedAllCands,
                        metadata: summary.metadata,
                        topCandidates: sortedAllCands.slice(0, 3)
                    };
                    
                } else {
                    e.summaryData = null;
                }
            } catch (error) {
                console.error(`è¼‰å…¥ ${e.file} æ‘˜è¦å¤±æ•—:`, error.message);
                e.summaryData = null; 
            }
            return e;
        });

        await Promise.all(summaryPromises);
    }

    // ================= æ’åºèˆ‡æ›´æ–°é‚è¼¯ =================
    
    window.sortTable = function(key) {
        
        const currentKey = appState.sortConfig.key;
        const currentDirection = appState.sortConfig.direction;
        
        let newDirection = 'desc'; 
        
        if (key === 'number' || key === 'name' || key === 'party') {
             newDirection = 'asc'; 
        }

        if (currentKey === key) {
            newDirection = currentDirection === 'asc' ? 'desc' : 'asc';
        }

        appState.sortConfig = { key: key, direction: newDirection };

        if (appState.currentLevel === 'county') {
            renderCounty(false); 
        } else if (appState.currentLevel === 'town') {
            renderTown(appState.currentTown, false); 
        }
    };
    
    function getSortedCandidates(candObj) {
        let list = Object.keys(candObj).map(key => ({ name: key, ...candObj[key] }));
        const { key, direction } = appState.sortConfig;
        
        list.sort((a, b) => {
            let valA = a[key], valB = b[key];

            if (key === 'number' || key === 'votes') { 
                valA = parseInt(valA) || 0; 
                valB = parseInt(valB) || 0;
            } else if (typeof valA === 'string') {
                 valA = valA.toLowerCase();
                 valB = valB.toLowerCase();
            }

            let comparison = 0;
            if (valA < valB) {
                comparison = -1;
            } else if (valA > valB) {
                comparison = 1;
            }

            return direction === 'asc' ? comparison : comparison * -1;
        });
        
        return list;
    }
    
    /**
     * è¼”åŠ©å‡½æ•¸ï¼šå°åˆ—è¡¨é€²è¡Œæ’åº (ä¸ä½¿ç”¨ appState.sortConfig)
     */
    function getSortedCandidatesFromList(list, sortConfig = { key: 'votes', direction: 'desc' }) {
        const { key, direction } = sortConfig;
        
        list.sort((a, b) => {
            let valA = a[key], valB = b[key];

            if (key === 'number' || key === 'votes') { 
                valA = parseInt(valA) || 0; 
                valB = parseInt(valB) || 0;
            } else if (typeof valA === 'string') {
                 valA = valA.toLowerCase();
                 valB = valB.toLowerCase();
            }

            let comparison = 0;
            if (valA < valB) {
                comparison = -1;
            } else if (valA > valB) {
                comparison = 1;
            }

            return direction === 'asc' ? comparison : comparison * -1;
        });
        
        return list;
    }
    
    /**
     * ç”Ÿæˆè¡¨æ ¼å…§å®¹ HTMLï¼Œä¸¦åŒ…å«é•·æ¢åœ–æ¬„ä½
     */
    function generateTableBodyHTML(candidates, validVotes) {
        return candidates.map(c => {
            const rate = validVotes > 0 ? (c.votes / validVotes * 100).toFixed(2) : 0;
            const color = getPartyColor(c.party); 
            
            const badgeClass = 'number-badge'; 
            
            const partyDisplayName = getShortPartyName(c.party); 
            
            return `
                <tr>
                    <td class="number-cell col-number">
                        <span class="${badgeClass}">${c.number}</span>
                    </td>
                    <td style="font-weight:700">${c.name}</td>
                    <td class="party-cell col-party">
                        <span class="party-badge party-long" style="background:${color}">${partyDisplayName}</span>
                        <span class="party-badge party-short" style="background:${color}">${partyDisplayName.substring(0, 3)}</span>
                    </td>
                    <td class="col-bar"> 
                        <div class="bar-container">
                            <div class="bar-fill" style="width:${rate}%; background:${color}"></div>
                        </div>
                    </td>
                    <td style="text-align:right">${c.votes.toLocaleString()}</td>
                    <td style="text-align:right; font-weight:bold; color:${color}">${rate}%</td>
                </tr>
            `;
        }).join('');
    }
    
    function updateTableContent(cardId, candidates, validVotes) {
        const mainTableBody = document.querySelector(`#card-${cardId} table tbody`); 
        if (mainTableBody) {
             mainTableBody.innerHTML = generateTableBodyHTML(candidates, validVotes);
        }
        updateSortIcons(); 
    }
    
    function updateSortIcons() {
        const { key, direction } = appState.sortConfig;
        document.querySelectorAll('th .sort-icon').forEach(icon => {
            const iconKey = icon.getAttribute('data-key');
            icon.className = 'sort-icon'; 
            if (iconKey === key) {
                icon.classList.add(direction); 
            }
        });
    }

    // ================= é é¢æ¸²æŸ“å‡½å¼ =================
    
    /**
     * æ–°å¢ï¼šç”Ÿæˆæ‘˜è¦å¡ç‰‡çš„ HTML 
     */
    function generateSummaryCardHTML(election) {
        if (!election.summaryData) {
            return `<div class="card failed">
                <div class="card-title">${election.uiName}</div>
                <div class="card-stats" style="color:red; margin-left:0;">è³‡æ–™è¼‰å…¥å¤±æ•—æˆ–æª”æ¡ˆéºå¤±ã€‚</div>
            </div>`;
        }

        const { allCandidates, metadata } = election.summaryData;
        
        return generateCardHTML(
            `summary-${election.file.replace(/[^a-zA-Z0-9]/g, '-')}`, 
            election.uiName, 
            allCandidates, 
            metadata, 
            true, 
            `loadData('${election.file}', '${election.uiName}')`, 
            true, // isCompact
            true  // isSummary
        );
    }

    /**
     * æ¸²æŸ“ä¸»é¸å–®é é¢ (é¦–é )
     */
    window.renderMainMenu = function() {
        appState.currentLevel = 'mainMenu';
        window.scrollTo(0, 0); 
        updateBreadcrumb(); 

        let html = '';

        // 1. ä¸»è¦æŒ‰éˆ•é¸å–®
        html += `<div class="main-section">
            <div class="menu-section-title">ä¾é¸èˆ‰é¡åˆ¥ç€è¦½</div>
            <div class="main-menu-grid">`;
        
        electionCategories.forEach(cat => {
            // ä½¿ç”¨å…§å»ºçš„ icon
            const iconMapping = {
                "ç¸½çµ±å‰¯ç¸½çµ±": "ğŸ›ï¸",
                "ç«‹æ³•å§”å“¡": "âš–ï¸",
                "åœ‹å¤§ä»£è¡¨": "ğŸ“œ",
                "ç¸£é•·": "ğŸ‘¨â€ğŸ’¼",
                "ç¸£è­°å“¡": "ğŸ˜ï¸",
                "é„‰é®é•·": "ğŸ¢",
                "é„‰é®æ°‘ä»£è¡¨": "ğŸ‘¥",
                "æ‘é‡Œé•·": "ğŸ¡"
            };
            html += `<div class="menu-button" onclick="renderElectionList('${cat.type}')">
                <span class="menu-icon">${iconMapping[cat.type] || 'ğŸ—³ï¸'}</span>
                <span class="menu-text">${cat.type}</span>
            </div>`;
        });
        html += `</div></div>`;

        // 2. è¿‘æœŸé¸èˆ‰ (ä½¿ç”¨æ‘˜è¦å¡ç‰‡)
        const recentElections = [...availableElections].sort((a, b) => {
            return parseInt(b.year) - parseInt(a.year); 
        }).slice(0, 8); 

        if (recentElections.length > 0) {
            html += `<div class="main-section">
                <div class="menu-section-title">ğŸ“° è¿‘æœŸé¸èˆ‰</div>
                <div class="election-list-grid">`;
            
            recentElections.forEach(e => {
                html += generateSummaryCardHTML(e);
            });
            html += `</div></div>`;
        }

        dom.content.innerHTML = html;
        // ç”±æ–¼ç§»é™¤äº† Chart.jsï¼Œä¸å†éœ€è¦ drawSummaryCharts() 
    };
    
    /**
     * æ¸²æŸ“é¸èˆ‰åˆ—è¡¨é é¢ (é»æ“ŠæŒ‰éˆ•å¾Œé€²å…¥)
     */
    window.renderElectionList = function(type) {
        appState.currentLevel = 'electionList';
        appState.currentTown = type; 
        window.scrollTo(0, 0); 
        updateBreadcrumb(); 

        const matchingElections = availableElections.filter(e => e.type === type);
        matchingElections.sort((a, b) => b.year - a.year); 

        let html = `<div class="main-section">
            <div class="menu-section-title">ğŸ“ ${type} é¸èˆ‰åˆ—è¡¨</div>
        </div>`;
        
        if (matchingElections.length > 0) {
            html += `<div class="election-list-grid">`;
            matchingElections.forEach(e => {
                html += generateSummaryCardHTML(e); 
            });
            html += `</div>`;
        } else {
             html += `<div class="loading-state" style="padding:40px;">è©²é¡åˆ¥ç›®å‰ç„¡è³‡æ–™å¯ä¾›æŸ¥è©¢ã€‚</div>`;
        }

        dom.content.innerHTML = html;
        // ç”±æ–¼ç§»é™¤äº† Chart.jsï¼Œä¸å†éœ€è¦ drawSummaryCharts() 
    };


    // ================= å„€è¡¨æ¿æ ¸å¿ƒæ¸²æŸ“é‚è¼¯ =================

    window.renderCounty = function(shouldScroll = true) {
        const candidates = getSortedCandidates(appState.data.county);
        const metadata = appState.countyMetadata;
        
        if (!shouldScroll) {
            updateTableContent('county-main', candidates, metadata.validVotes);
            
            appState.data.townOrder.forEach(town => {
                const townData = appState.data.towns[town];
                const townCands = getSortedCandidates(townData.candidates);
                updateTableContent(`town-${town}`, townCands, townData.validVotes);
            });
            return; 
        }

        appState.currentLevel = 'county';
        appState.currentTown = null;
        window.scrollTo(0,0); 
        updateBreadcrumb();

        let html = `<div class="main-section">
            <div class="section-header"><span class="section-title">${appState.electionName}</span></div>
            ${generateCardHTML('county-main', 'å…¨ç¸£é–‹ç¥¨çµæœ', candidates, metadata, false, false, false, false)}
        </div>`;

        html += `<div class="main-section">
            <div class="section-header"><span class="section-title">å„é„‰é®é–‹ç¥¨çµæœ</span><span class="section-badge">é»æ“Šå¡ç‰‡çœ‹ç´°ç¯€</span></div>
            <div class="sub-area-grid">`;
        
        appState.data.townOrder.forEach(town => {
            const townData = appState.data.towns[town];
            const townCands = getSortedCandidates(townData.candidates);
            
            const townMetadata = {
                validVotes: townData.validVotes,
                invalidVotes: townData.invalidVotes,
                eligibleVoters: townData.eligibleVoters
            };

            html += generateCardHTML(`town-${town}`, town, townCands, townMetadata, true, `renderTown('${town}')`, true, false);
        });
        html += `</div></div>`;

        dom.content.innerHTML = html;
        updateSortIcons();
    };

    window.renderTown = function(townName, shouldScroll = true) {
        const townData = appState.data.towns[townName];
        const candidates = getSortedCandidates(townData.candidates);
        const townMetadata = {
            validVotes: townData.validVotes,
            invalidVotes: townData.invalidVotes,
            eligibleVoters: townData.eligibleVoters
        };
        
        if (!shouldScroll) {
            updateTableContent('town-main', candidates, townMetadata.validVotes);
            
            const villageList = Object.keys(townData.villages);
            villageList.forEach(village => {
                const vData = townData.villages[village];
                const vCands = getSortedCandidates(vData.candidates);
                updateTableContent(`village-${village}`, vCands, vData.validVotes);
            });
            return; 
        }
        
        appState.currentLevel = 'town';
        appState.currentTown = townName;
        window.scrollTo(0,0); 
        updateBreadcrumb();
        
        const villageList = Object.keys(townData.villages);

        let html = `<div class="main-section">
            <div class="section-header"><span class="section-title">${townName} ç¸½è¨ˆ</span></div>
            ${generateCardHTML('town-main', `${townName}é–‹ç¥¨çµæœ`, candidates, townMetadata, false, false, false, false)}
        </div>`;

        html += `<div class="main-section">
            <div class="section-header"><span class="section-title">å„æ‘é‡Œé–‹ç¥¨çµæœ</span></div>
            <div class="sub-area-grid">`;
        
        villageList.forEach(village => {
            const vData = townData.villages[village];
            const vCands = getSortedCandidates(vData.candidates);
            
            const villageMetadata = {
                validVotes: vData.validVotes,
                invalidVotes: vData.invalidVotes,
                eligibleVoters: vData.eligibleVoters
            };

            html += generateCardHTML(`village-${village}`, village, vCands, villageMetadata, false, null, true, false);
        });
        html += `</div></div>`;

        dom.content.innerHTML = html;
        updateSortIcons();
    };

    // ================= é€šç”¨è¼”åŠ©å‡½å¼ =================

    function updateBreadcrumb() {
        const level = appState.currentLevel;
        let html = '';

        if (level === 'mainMenu') {
            dom.breadcrumb.style.display = 'none';
            dom.breadcrumbBottom.style.display = 'none';
            return;
        }

        html += `<span onclick="renderMainMenu()">é¦–é </span> / `;

        if (level === 'electionList') {
            html += `<span class="active">${appState.currentTown}</span>`;
        } else if (level === 'county') {
            html += `<span onclick="renderElectionList('${availableElections.find(e => e.uiName === appState.electionName).type}')">${availableElections.find(e => e.uiName === appState.electionName).type}</span> / `;
            html += `<span class="active">${appState.electionName}</span>`;
        } else if (level === 'town') {
             const electionType = availableElections.find(e => e.uiName === appState.electionName).type;
             html += `<span onclick="renderElectionList('${electionType}')">${electionType}</span> / `;
             html += `<span onclick="renderCounty(true)">${appState.electionName}</span> / `;
             html += `<span class="active">${appState.currentTown}</span>`;
        }

        dom.breadcrumb.innerHTML = html;
        dom.breadcrumb.style.display = 'block';
        dom.breadcrumbBottom.innerHTML = html;
        dom.breadcrumbBottom.style.display = 'block';
    }


    /**
     * ç”Ÿæˆå¡ç‰‡ HTML (é€šç”¨æ¨¡æ¿)
     * ç”±æ–¼ç§»é™¤äº† Chart.jsï¼Œé€™å€‹å‡½å¼ä¹Ÿè®Šå¾—æ›´ç°¡æ½”ã€‚
     */
    function generateCardHTML(id, title, candidates, metadata, isClickable, onClickAction, isCompact = false, isSummary = false) {
        
        const clickClass = isClickable ? 'clickable' : '';
        const clickAttr = isClickable ? `onclick="${onClickAction}"` : '';
        
        const actionText = isClickable ? `<span class="card-action">æŸ¥çœ‹è©³æƒ… âœ</span>` : '';
        
        const layoutClass = isCompact ? 'layout-compact' : 'layout-full';
        const summaryClass = isSummary ? 'is-summary' : '';
        
        const tableSizeClass = isCompact ? '' : ' large-table';
        
        const { validVotes, invalidVotes, eligibleVoters } = metadata;
        
        const totalBallots = validVotes + invalidVotes;
        const turnoutRate = eligibleVoters > 0 ? (totalBallots / eligibleVoters * 100).toFixed(2) : "0.00";

        // çµ±è¨ˆæ•¸æ“š HTML 
        let cardStatsHTML;
        if (isSummary) {
             cardStatsHTML = `
                <div class="card-stats">
                    <span style="white-space: nowrap;">
                        æœ‰æ•ˆç¥¨: ${validVotes.toLocaleString()} ç¥¨ 
                        <span style="color:var(--text-sub); margin: 0 5px;">|</span>
                        æŠ•ç¥¨ç‡: <span class="rate">${turnoutRate}%</span>
                    </span>
                </div>
            `;
        } else {
             cardStatsHTML = `
                <div class="card-stats">
                    <span style="font-size:14px;">æœ‰æ•ˆç¥¨: ${validVotes.toLocaleString()} ç¥¨</span> 
                    | ç„¡æ•ˆç¥¨: ${invalidVotes.toLocaleString()} ç¥¨ 
                    <br>
                    <span style="white-space: nowrap;">
                        é¸èˆ‰äººæ•¸: ${eligibleVoters.toLocaleString()} äºº 
                        | æŠ•ç¥¨ç‡: <span class="rate">${turnoutRate}%</span>
                    </span>
                </div>
            `;
        }


        const { key: currentSortKey, direction: currentSortDirection } = appState.sortConfig;

        function renderTableHeader(title, sortKey, style = '', className = '') {
            if (sortKey === 'votes_bar') {
                 // æ»¿è¶³è¦æ±‚ 2ï¼šé•·æ¢åœ–æ¬„ä½ä¸è¨­æ¨™é¡Œåˆ—åç¨±
                 return `<th style="${style}" class="${className}"></th>`; 
            }
            
            if (isSummary) {
                 if (sortKey === 'party') {
                     return `<th style="${style}" class="${className} col-party"><span class="party-title-desktop">æ¨è–¦æ”¿é»¨</span><span class="party-title-mobile">æ”¿é»¨</span></th>`;
                 }
                 return `<th style="${style}" class="${className}">${title}</th>`;
            }
            
            const isCurrentKey = currentSortKey === sortKey;
            const iconClass = isCurrentKey ? currentSortDirection : '';
            const iconHtml = `<span data-key="${sortKey}" class="sort-icon ${iconClass}"></span>`;
            
            let titleHTML = title;
            if (sortKey === 'party') {
                titleHTML = `<span class="party-title-desktop">æ¨è–¦æ”¿é»¨</span><span class="party-title-mobile">æ”¿é»¨</span>`;
            }
            
            return `<th style="${style}" class="${className}" onclick="event.stopPropagation(); sortTable('${sortKey}')">${titleHTML} ${iconHtml}</th>`;
        }
        
        const tableBodyHTML = generateTableBodyHTML(candidates, validVotes);
        
        return `
        <div class="card ${clickClass} ${summaryClass}" ${clickAttr} id="card-${id}">
            <div class="card-header">
                <div class="card-header-left">
                    <div class="card-title">${title}</div>
                    ${cardStatsHTML}
                </div>
                ${actionText}
            </div>
            <div class="table-area table-responsive">
                <table class="${tableSizeClass}">
                    <thead>
                        <tr>
                            ${renderTableHeader('#', 'number', 'width:40px; text-align:center;', 'col-number')} 
                            ${renderTableHeader('å€™é¸äºº', 'name', '', '')}
                            ${renderTableHeader('æ¨è–¦æ”¿é»¨', 'party', '', 'col-party')}
                            
                            ${renderTableHeader('', 'votes_bar', 'width:150px;', 'col-bar')} 
                            
                            ${renderTableHeader('å¾—ç¥¨', 'votes', 'text-align:right')}
                            ${renderTableHeader('%', 'votes', 'text-align:right; width:50px')}
                        </tr>
                    </thead>
                    <tbody>
                        ${tableBodyHTML}
                    </tbody>
                </table>
            </div>
        </div>`;
    }


    // ================= åˆå§‹åŒ– =================

    (function init() {
        dom.content.innerHTML = `<div class="loading-state">æ­£åœ¨è¼‰å…¥æ‰€æœ‰é¸èˆ‰æ‘˜è¦æ•¸æ“š...è«‹ç¨å€™ã€‚</div>`;
        loadAllElectionSummaries(availableElections).then(() => {
            renderMainMenu(); 
        });
    })();
</script>
</body>
</html>
